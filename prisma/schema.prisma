generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USER & AUTHENTICATION
// ============================================

enum UserRole {
  PHOTOGRAPHER
  BUYER
  ADMIN
  SPECIALIST
}

enum KycStatus {
  PENDING
  IN_PROGRESS
  VERIFIED
  REJECTED
}

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  email         String    @unique
  emailVerified DateTime?
  passwordHash  String?
  name          String?
  image         String?
  roles         UserRole[] @default([BUYER])

  // KYC/Sumsub integration
  kycStatus         KycStatus @default(PENDING)
  kycVerifiedAt     DateTime?
  sumsubApplicantId String?   @unique

  // Telegram integration
  telegramUserId    String?   @unique
  telegramUsername  String?
  telegramLinkedAt  DateTime?

  // Relations
  photographerProfile  PhotographerProfile?
  photos               Photo[]
  licenseRequests      LicenseRequest[]
  adminReviews         AdminReview[]
  telegramLinkTokens   TelegramLinkToken[]
  accounts             Account[]
  sessions             Session[]
  wallet               Wallet?
  purchases            Purchase[]       @relation("BuyerPurchases")
  buyerRequests        PhotoRequest[]   @relation("BuyerRequests")
  photographerRequests PhotoRequest[]   @relation("PhotographerRequests")
  taskRequests         TaskRequest[]
  taskMessages         TaskMessage[]

  @@index([email])
  @@index([telegramUserId])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// PHOTOGRAPHER PROFILE
// ============================================

model PhotographerProfile {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  userId          String   @unique
  displayName     String
  handle          String   @unique
  bio             String?  @db.Text
  location        String?
  websiteUrl      String?
  socialInstagram String?
  socialX         String?
  socialLinkedin  String?
  avatarUrl       String?
  coverImageUrl   String?
  isVerified      Boolean  @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([handle])
}

// ============================================
// PHOTOS & VERIFICATION
// ============================================

enum PhotoStatus {
  UPLOADING
  PENDING_REVIEW
  VERIFIED
  REJECTED
}

model Photo {
  id              String      @id @default(cuid())
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  photographerId  String

  // Basic info
  title           String
  description     String?     @db.Text
  category        String?

  // File storage
  fileUrl         String
  thumbnailUrl    String?
  mediumUrl       String?
  storageKey      String
  location        String?

  // Status & verification
  status          PhotoStatus @default(UPLOADING)
  verificationScore Float?
  verificationNotes String?    @db.Text
  verifiedAt      DateTime?

  // Technical metadata (EXIF)
  width           Int?
  height          Int?
  fileSize        Int?
  mimeType        String?
  shootDate       DateTime?
  cameraMake      String?
  cameraModel     String?
  lens            String?
  aperture        String?
  shutterSpeed    String?
  iso             Int?
  focalLength     String?
  gpsLatitude     Float?
  gpsLongitude    Float?

  // Integrity
  fileHash        String      @unique

  // Visual analysis (optional)
  primaryColor    String?
  dominantColors  String[]

  // Relations
  photographer      User        @relation(fields: [photographerId], references: [id], onDelete: Cascade)
  tags              PhotoTag[]
  licenseOptions    LicenseOption[]
  licenseRequests   LicenseRequest[]
  adminReviews      AdminReview[]
  purchases         Purchase[]
  deliveredRequests PhotoRequest[] @relation("DeliveredPhoto")

  @@index([photographerId])
  @@index([status])
  @@index([createdAt])
  @@index([fileHash])
  @@index([category])
}

model Tag {
  id        String     @id @default(cuid())
  name      String     @unique
  slug      String     @unique
  photos    PhotoTag[]

  @@index([slug])
}

model PhotoTag {
  photoId String
  tagId   String
  photo   Photo  @relation(fields: [photoId], references: [id], onDelete: Cascade)
  tag     Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([photoId, tagId])
}

// ============================================
// LICENSING
// ============================================

enum LicenseType {
  PERSONAL
  EDITORIAL
  COMMERCIAL
  EXTENDED
}

model LicenseOption {
  id          String      @id @default(cuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  photoId     String
  type        LicenseType
  name        String
  description String?     @db.Text
  priceCents  Int
  credits     Int         @default(0) // Price in credits
  currency    String      @default("USD")
  usageTerms  String?     @db.Text
  isActive    Boolean     @default(true)

  photo     Photo       @relation(fields: [photoId], references: [id], onDelete: Cascade)
  requests  LicenseRequest[]
  purchases Purchase[]

  @@index([photoId])
}

enum RequestStatus {
  OPEN
  IN_REVIEW
  APPROVED
  DECLINED
  COMPLETED
}

model LicenseRequest {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  photoId         String
  buyerId         String
  licenseOptionId String?
  status          RequestStatus @default(OPEN)
  message         String?       @db.Text
  intendedUse     String?       @db.Text
  adminNotes      String?       @db.Text

  photo         Photo         @relation(fields: [photoId], references: [id], onDelete: Cascade)
  buyer         User          @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  licenseOption LicenseOption? @relation(fields: [licenseOptionId], references: [id])

  @@index([photoId])
  @@index([buyerId])
  @@index([status])
}

// ============================================
// ADMIN & MODERATION
// ============================================

enum ReviewDecision {
  VERIFIED
  REJECTED
  NEEDS_INFO
}

model AdminReview {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  photoId   String
  adminId   String
  decision  ReviewDecision
  notes     String?        @db.Text

  photo Photo @relation(fields: [photoId], references: [id], onDelete: Cascade)
  admin User  @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([photoId])
  @@index([adminId])
}

// ============================================
// TELEGRAM INTEGRATION
// ============================================

model TelegramLinkToken {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  usedAt    DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
}

// ============================================
// WALLET & CREDITS SYSTEM
// ============================================

model Wallet {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userId        String   @unique
  balance       Int      @default(0) // Credits balance
  totalSpent    Int      @default(0) // Total credits spent
  totalEarnings Int      @default(0) // For photographers - lifetime earnings
  pendingPayout Int      @default(0) // Pending photographer earnings

  user         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions CreditTransaction[]
}

enum TransactionType {
  CREDIT_PURCHASE      // Buyer purchased credits
  PHOTO_PURCHASE       // Buyer spent credits on a photo
  PHOTOGRAPHER_EARNING // Photographer received credits from sale
  REFUND               // Credits refunded
  BONUS                // Promotional credits
}

model CreditTransaction {
  id          String          @id @default(cuid())
  createdAt   DateTime        @default(now())
  walletId    String
  type        TransactionType
  amount      Int             // Positive for credits in, negative for credits out
  balance     Int             // Balance after transaction
  description String?
  metadata    Json?           // Store payment info, photo ID, etc.

  wallet     Wallet    @relation(fields: [walletId], references: [id], onDelete: Cascade)
  purchase   Purchase? @relation(fields: [purchaseId], references: [id])
  purchaseId String?

  @@index([walletId])
  @@index([type])
  @@index([createdAt])
}

// ============================================
// PURCHASES & DOWNLOADS
// ============================================

enum PurchaseStatus {
  PENDING
  COMPLETED
  REFUNDED
}

model Purchase {
  id              String         @id @default(cuid())
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  buyerId         String
  photoId         String
  licenseOptionId String
  status          PurchaseStatus @default(COMPLETED)
  creditsCost     Int            // Credits spent
  photographerCut Int            // Credits to photographer (80%)
  platformCut     Int            // Platform fee (20%)
  downloadToken   String         @unique @default(cuid())
  downloadCount   Int            @default(0)
  maxDownloads    Int            @default(5)

  buyer         User                @relation("BuyerPurchases", fields: [buyerId], references: [id])
  photo         Photo               @relation(fields: [photoId], references: [id])
  licenseOption LicenseOption       @relation(fields: [licenseOptionId], references: [id])
  transactions  CreditTransaction[]

  @@index([buyerId])
  @@index([photoId])
  @@index([downloadToken])
  @@index([status])
}

// ============================================
// PHOTO REQUESTS (Custom commissions)
// ============================================

enum PhotoRequestStatus {
  PENDING
  ACCEPTED
  IN_PROGRESS
  DELIVERED
  COMPLETED
  DECLINED
  CANCELLED
}

model PhotoRequest {
  id             String             @id @default(cuid())
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  buyerId        String
  photographerId String
  status         PhotoRequestStatus @default(PENDING)

  // Request details
  title          String
  description    String             @db.Text
  category       String?
  budget         Int?               // Budget in credits
  deadline       DateTime?

  // Response
  photographerNotes String?         @db.Text
  quotedPrice    Int?               // Photographer's quote in credits

  // Delivery
  deliveredPhotoId String?

  buyer          User   @relation("BuyerRequests", fields: [buyerId], references: [id])
  photographer   User   @relation("PhotographerRequests", fields: [photographerId], references: [id])
  deliveredPhoto Photo? @relation("DeliveredPhoto", fields: [deliveredPhotoId], references: [id])

  @@index([buyerId])
  @@index([photographerId])
  @@index([status])
}

// ============================================
// AI SPECIALISTS & TASKS
// ============================================

model Specialist {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  firstName       String
  avatarSeed      String   // Seed for DiceBear avatar generation
  bio             String?  @db.Text
  hourlyRate      Float    @default(50)
  rating          Float    @default(5.0)
  totalTasks      Int      @default(0)
  completedTasks  Int      @default(0)
  isAvailable     Boolean  @default(true)

  // Link to User account (optional - for real executors)
  userId          String?  @unique

  // Telegram integration for executors
  telegramUserId    String?  @unique
  telegramUsername  String?
  telegramLinkedAt  DateTime?

  tasks           SpecialistTask[]
  assignments     TaskAssignment[]

  @@index([rating])
  @@index([isAvailable])
  @@index([userId])
  @@index([telegramUserId])
}

model Task {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  name        String   @unique
  displayName String
  description String   @db.Text
  category    String
  basePrice   Float    @default(100)

  specialists SpecialistTask[]
  requests    TaskRequest[]

  @@index([category])
  @@index([name])
}

model SpecialistTask {
  id           String     @id @default(cuid())
  specialistId String
  taskId       String
  proficiency  Float      @default(1.0) // 0-1 scale for AI matching

  specialist   Specialist @relation(fields: [specialistId], references: [id], onDelete: Cascade)
  task         Task       @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@unique([specialistId, taskId])
}

enum TaskRequestStatus {
  PENDING      // User submitted, awaiting AI matching
  MATCHED      // AI found specialists
  PAID         // User paid for assignment
  IN_PROGRESS  // Specialist working
  COMPLETED    // Task done
  CANCELLED
}

enum AssignmentStatus {
  PENDING      // Suggested by AI
  ACCEPTED     // User selected this specialist
  IN_PROGRESS  // Specialist working
  COMPLETED    // Task completed
  RATED        // User rated the work
}

model TaskRequest {
  id          String            @id @default(cuid())
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  userId      String
  description String            @db.Text
  status      TaskRequestStatus @default(PENDING)
  totalCost   Float?
  taskId      String?

  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  task        Task?             @relation(fields: [taskId], references: [id])
  assignments TaskAssignment[]

  @@index([userId])
  @@index([status])
}

model TaskAssignment {
  id           String           @id @default(cuid())
  createdAt    DateTime         @default(now())
  requestId    String
  specialistId String
  status       AssignmentStatus @default(PENDING)
  price        Float
  confidence   Float?           // AI matching confidence score
  reasoning    String?          @db.Text
  rating       Float?
  feedback     String?          @db.Text
  startedAt    DateTime?
  completedAt  DateTime?

  request      TaskRequest      @relation(fields: [requestId], references: [id], onDelete: Cascade)
  specialist   Specialist       @relation(fields: [specialistId], references: [id], onDelete: Cascade)
  messages     TaskMessage[]

  @@unique([requestId, specialistId])
  @@index([status])
}

// ============================================
// TASK MESSAGING
// ============================================

model TaskMessage {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  assignmentId String
  senderId     String
  senderRole   String   // "BUYER" | "SPECIALIST" | "ADMIN"
  content      String   @db.Text

  assignment   TaskAssignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  sender       User           @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([assignmentId])
  @@index([createdAt])
}
